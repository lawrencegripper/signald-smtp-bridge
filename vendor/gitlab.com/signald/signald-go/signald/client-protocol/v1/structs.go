package v1

// DO NOT EDIT: this file is automatically generated by ./tools/generator in this repo

import (
	"gitlab.com/signald/signald-go/signald/client-protocol/v0"
)

type Request struct {
	ID      string `json:"id" yaml:"id"`
	Version string `json:"version" yaml:"version"`
	Type    string `json:"type" yaml:"type"`
}

// AcceptInvitationRequest: Accept a v2 group invitation. Note that you must have a profile name set to join groups.
type AcceptInvitationRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	GroupID string `json:"groupID,omitempty" yaml:"groupID,omitempty"`
}

// Account: A local account in signald
type Account struct {
	AccountId string       `json:"account_id,omitempty" yaml:"account_id,omitempty"` // The primary identifier on the account, included with all requests to signald for this account. Previously called 'username'
	Address   *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"`       // The address of this account
	DeviceId  int32        `json:"device_id,omitempty" yaml:"device_id,omitempty"`   // The Signal device ID. Official Signal mobile clients (iPhone and Android) have device ID = 1, while linked devices such as Signal Desktop or Signal iPad have higher device IDs.
	Pending   bool         `json:"pending,omitempty" yaml:"pending,omitempty"`       // indicates the account has not completed registration
	Pni       string       `json:"pni,omitempty" yaml:"pni,omitempty"`
}

type AccountList struct {
	Accounts []*Account `json:"accounts,omitempty" yaml:"accounts,omitempty"`
}

// AddLinkedDeviceRequest: Link a new device to a local Signal account
type AddLinkedDeviceRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	Uri     string `json:"uri,omitempty" yaml:"uri,omitempty"`         // the sgnl://linkdevice uri provided (typically in qr code form) by the new device
}

// AddServerRequest: add a new server to connect to. Returns the new server's UUID.
type AddServerRequest struct {
	Request
	Server *Server `json:"server,omitempty" yaml:"server,omitempty"`
}

type AllIdentityKeyList struct {
	IdentityKeys []*IdentityKeyList `json:"identity_keys,omitempty" yaml:"identity_keys,omitempty"`
}

type AnswerMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
}

// ApproveMembershipRequest: approve a request to join a group
type ApproveMembershipRequest struct {
	Request
	Account string         `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	GroupID string         `json:"groupID,omitempty" yaml:"groupID,omitempty"`
	Members []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"` // list of requesting members to approve
}

// BanUserRequest: Bans users from a group. This works even if the users aren't in the group. If they are currently in the group, they will also be removed.
type BanUserRequest struct {
	Request
	Account string         `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	GroupId string         `json:"group_id,omitempty" yaml:"group_id,omitempty"`
	Users   []*JsonAddress `json:"users,omitempty" yaml:"users,omitempty"` // List of users to ban
}

type BannedGroupMember struct {
	Timestamp int64  `json:"timestamp,omitempty" yaml:"timestamp,omitempty"` // Timestamp as milliseconds since Unix epoch of when the user was banned. This field is set by the server.
	UUID      string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// BooleanMessage: A message containing a single boolean, usually as a response
type BooleanMessage struct {
	Value bool `json:"value,omitempty" yaml:"value,omitempty"`
}

type BusyMessage struct {
	ID int64 `json:"id,omitempty" yaml:"id,omitempty"`
}

type CallMessage struct {
	AnswerMessage       *AnswerMessage      `json:"answer_message,omitempty" yaml:"answer_message,omitempty"`
	BusyMessage         *BusyMessage        `json:"busy_message,omitempty" yaml:"busy_message,omitempty"`
	DestinationDeviceId int32               `json:"destination_device_id,omitempty" yaml:"destination_device_id,omitempty"`
	HangupMessage       *HangupMessage      `json:"hangup_message,omitempty" yaml:"hangup_message,omitempty"`
	IceUpdateMessage    []*IceUpdateMessage `json:"ice_update_message,omitempty" yaml:"ice_update_message,omitempty"`
	MultiRing           bool                `json:"multi_ring,omitempty" yaml:"multi_ring,omitempty"`
	OfferMessage        *OfferMessage       `json:"offer_message,omitempty" yaml:"offer_message,omitempty"`
}

type Capabilities struct {
	AnnouncementGroup bool `json:"announcement_group,omitempty" yaml:"announcement_group,omitempty"`
	ChangeNumber      bool `json:"change_number,omitempty" yaml:"change_number,omitempty"`
	Gv1Migration      bool `json:"gv1-migration,omitempty" yaml:"gv1-migration,omitempty"`
	Gv2               bool `json:"gv2,omitempty" yaml:"gv2,omitempty"` // this capability is deprecated and will always be true
	SenderKey         bool `json:"sender_key,omitempty" yaml:"sender_key,omitempty"`
	Storage           bool `json:"storage,omitempty" yaml:"storage,omitempty"`
	Stories           bool `json:"stories,omitempty" yaml:"stories,omitempty"`
}

// ClientMessageWrapper: Wraps all incoming messages sent to the client after a v1 subscribe request is issued
type ClientMessageWrapper struct {
	Account string      `json:"account,omitempty" yaml:"account,omitempty"` // the account this message is from
	Data    interface{} `json:"data,omitempty" yaml:"data,omitempty"`       // the incoming object. The structure will vary from message to message, see `type` and `version` fields
	Error   bool        `json:"error,omitempty" yaml:"error,omitempty"`     // true if the incoming message represents an error
	Type    string      `json:"type,omitempty" yaml:"type,omitempty"`       // the type of object to expect in the `data` field
	Version string      `json:"version,omitempty" yaml:"version,omitempty"` // the version of the object in the `data` field
}

type CreateGroupRequest struct {
	Request
	Account    string         `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	Avatar     string         `json:"avatar,omitempty" yaml:"avatar,omitempty"`
	MemberRole string         `json:"member_role,omitempty" yaml:"member_role,omitempty"` // The role of all members other than the group creator. Options are ADMINISTRATOR or DEFAULT (case insensitive)
	Members    []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"`
	Timer      int32          `json:"timer,omitempty" yaml:"timer,omitempty"` // the message expiration timer
	Title      string         `json:"title,omitempty" yaml:"title,omitempty"`
}

// DeleteAccountRequest: delete all account data signald has on disk, and optionally delete the account from the server as well. Note that this is not "unlink" and will delete the entire account, even from a linked device.
type DeleteAccountRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to delete
	Server  bool   `json:"server,omitempty" yaml:"server,omitempty"`   // delete account information from the server as well (default false)
}

type DeviceInfo struct {
	Created  int64  `json:"created,omitempty" yaml:"created,omitempty"`
	ID       int64  `json:"id,omitempty" yaml:"id,omitempty"`
	LastSeen int64  `json:"lastSeen,omitempty" yaml:"lastSeen,omitempty"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty"`
}

// FinishLinkRequest: After a linking URI has been requested, finish_link must be called with the session_id provided with the URI. it will return information about the new account once the linking process is completed by the other device and the new account is setup. Note that the account setup process can sometimes take some time, if rapid userfeedback is required after scanning, use wait_for_scan first, then finish setup with finish_link.
type FinishLinkRequest struct {
	Request
	DeviceName string `json:"device_name,omitempty" yaml:"device_name,omitempty"`
	Overwrite  bool   `json:"overwrite,omitempty" yaml:"overwrite,omitempty"` // overwrite existing account data if the phone number conflicts. false by default
	SessionId  string `json:"session_id,omitempty" yaml:"session_id,omitempty"`
}

// GenerateLinkingURIRequest: Generate a linking URI. Typically this is QR encoded and scanned by the primary device. Submit the returned session_id with a finish_link request.
type GenerateLinkingURIRequest struct {
	Request
	Server string `json:"server,omitempty" yaml:"server,omitempty"` // The identifier of the server to use. Leave blank for default (usually Signal production servers but configurable at build time)
}

// GetAllIdentities: get all known identity keys
type GetAllIdentities struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
}

// GetGroupRequest: Query the server for the latest state of a known group. If the account is not a member of the group, an UnknownGroupError is returned.
type GetGroupRequest struct {
	Request
	Account  string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	GroupID  string `json:"groupID,omitempty" yaml:"groupID,omitempty"`
	Revision int32  `json:"revision,omitempty" yaml:"revision,omitempty"` // the latest known revision, default value (-1) forces fetch from server
}

// GetGroupRevisionPagesRequest: Query the server for group revision history. The history contains information about the changes between each revision and the user that made the change.
type GetGroupRevisionPagesRequest struct {
	Request
	Account              string `json:"account,omitempty" yaml:"account,omitempty"`             // The account to interact with
	FromRevision         int32  `json:"from_revision,omitempty" yaml:"from_revision,omitempty"` // The revision to start the pages from. Note that if this is lower than the revision you joined the group, an AuthorizationFailedError is returned.
	GroupId              string `json:"group_id,omitempty" yaml:"group_id,omitempty"`
	IncludeFirstRevision bool   `json:"include_first_revision,omitempty" yaml:"include_first_revision,omitempty"` // Whether to include the first state in the returned pages (default false)
}

// GetIdentitiesRequest: Get information about a known keys for a particular address
type GetIdentitiesRequest struct {
	Request
	Account string       `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	Address *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"` // address to get keys for
}

// GetLinkedDevicesRequest: list all linked devices on a Signal account
type GetLinkedDevicesRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
}

// GetProfileRequest: Get all information available about a user
type GetProfileRequest struct {
	Request
	Account string       `json:"account,omitempty" yaml:"account,omitempty"` // the signald account to use
	Address *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"` // the address to look up
	Async   bool         `json:"async,omitempty" yaml:"async,omitempty"`     // if true, return results from local store immediately, refreshing from server in the background if needed. if false (default), block until profile can be retrieved from server
}

type GetServersRequest struct {
	Request
}

type Gradient struct {
	EndColor   string `json:"end_color,omitempty" yaml:"end_color,omitempty"`
	StartColor string `json:"start_color,omitempty" yaml:"start_color,omitempty"`
}

// GroupAccessControl: group access control settings. Options for each controlled action are: UNKNOWN, ANY, MEMBER, ADMINISTRATOR, UNSATISFIABLE and UNRECOGNIZED
type GroupAccessControl struct {
	Attributes string `json:"attributes,omitempty" yaml:"attributes,omitempty"` // who can edit group info
	Link       string `json:"link,omitempty" yaml:"link,omitempty"`             // UNSATISFIABLE when the group link is disabled, ADMINISTRATOR when the group link is enabled but an administrator must approve new members, ANY when the group link is enabled and no approval is required
	Members    string `json:"members,omitempty" yaml:"members,omitempty"`       // who can add members
}

// GroupChange: Represents a group change made by a user. This can also represent request link invites. Only the fields relevant to the group change performed will be set. Note that in signald, group changes are currently only received from incoming messages from a message subscription.
type GroupChange struct {
	DeleteMembers            []*JsonAddress           `json:"delete_members,omitempty" yaml:"delete_members,omitempty"` // Represents users that have been removed from the group. This can be from admins removing users, or users choosing to leave the group
	DeletePendingMembers     []*JsonAddress           `json:"delete_pending_members,omitempty" yaml:"delete_pending_members,omitempty"`
	DeleteRequestingMembers  []*JsonAddress           `json:"delete_requesting_members,omitempty" yaml:"delete_requesting_members,omitempty"`
	Editor                   *JsonAddress             `json:"editor,omitempty" yaml:"editor,omitempty"`                               // The user that made the change.
	ModifiedProfileKeys      []*GroupMember           `json:"modified_profile_keys,omitempty" yaml:"modified_profile_keys,omitempty"` // Represents users that have rotated their profile key. Note that signald currently does not expose profile keys to clients. The joined revision property will always be 0 in this list.
	ModifyMemberRoles        []*GroupMember           `json:"modify_member_roles,omitempty" yaml:"modify_member_roles,omitempty"`     // Represents users with their new, modified role.
	NewAccessControl         *GroupAccessControl      `json:"new_access_control,omitempty" yaml:"new_access_control,omitempty"`       // If not null, then this group change modified one of the access controls. Some of the properties in here will be null.
	NewAvatar                bool                     `json:"new_avatar,omitempty" yaml:"new_avatar,omitempty"`                       // Whether this group change changed the avatar.
	NewBannedMembers         []*BannedGroupMember     `json:"new_banned_members,omitempty" yaml:"new_banned_members,omitempty"`
	NewDescription           string                   `json:"new_description,omitempty" yaml:"new_description,omitempty"`
	NewInviteLinkPassword    bool                     `json:"new_invite_link_password,omitempty" yaml:"new_invite_link_password,omitempty"`   // Whether this group change involved resetting the group invite link.
	NewIsAnnouncementGroup   string                   `json:"new_is_announcement_group,omitempty" yaml:"new_is_announcement_group,omitempty"` // Whether this change affected the announcement group setting. Possible values are UNKNOWN, ENABLED or DISABLED
	NewMembers               []*GroupMember           `json:"new_members,omitempty" yaml:"new_members,omitempty"`                             // Represents users have been added to the group. This can be from group members adding users, or a users joining via a group link that required no approval.
	NewPendingMembers        []*GroupPendingMember    `json:"new_pending_members,omitempty" yaml:"new_pending_members,omitempty"`             // Represents a user that has been invited to the group by another user.
	NewRequestingMembers     []*GroupRequestingMember `json:"new_requesting_members,omitempty" yaml:"new_requesting_members,omitempty"`       // Represents users that have requested to join the group via the group link. Note that members requesting to join might not necessarily have the list of users in the group, so they won't be able to send a peer-to-peer group update message to inform users of their request to join. Other users in the group may inform us that the revision has increased, but the members requesting access will have to be obtained from the server instead (which signald will handle). For now, a get_group request has to be made to get the users that have requested to join the group.
	NewTimer                 int32                    `json:"new_timer,omitempty" yaml:"new_timer,omitempty"`                                 // New disappearing messages timer value.
	NewTitle                 string                   `json:"new_title,omitempty" yaml:"new_title,omitempty"`
	NewUnbannedMembers       []*BannedGroupMember     `json:"new_unbanned_members,omitempty" yaml:"new_unbanned_members,omitempty"`
	PromotePendingMembers    []*GroupMember           `json:"promote_pending_members,omitempty" yaml:"promote_pending_members,omitempty"`
	PromoteRequestingMembers []*GroupMember           `json:"promote_requesting_members,omitempty" yaml:"promote_requesting_members,omitempty"`
	Revision                 int32                    `json:"revision,omitempty" yaml:"revision,omitempty"` // The group revision that this change brings the group to.
}

type GroupHistoryEntry struct {
	Change *GroupChange     `json:"change,omitempty" yaml:"change,omitempty"`
	Group  *JsonGroupV2Info `json:"group,omitempty" yaml:"group,omitempty"`
}

// GroupHistoryPage: The result of fetching a group's history along with paging data.
type GroupHistoryPage struct {
	PagingData *PagingData          `json:"paging_data,omitempty" yaml:"paging_data,omitempty"`
	Results    []*GroupHistoryEntry `json:"results,omitempty" yaml:"results,omitempty"`
}

// GroupInfo: A generic type that is used when the group version is not known
type GroupInfo struct {
	V1 *JsonGroupInfo   `json:"v1,omitempty" yaml:"v1,omitempty"`
	V2 *JsonGroupV2Info `json:"v2,omitempty" yaml:"v2,omitempty"`
}

// GroupLinkInfoRequest: Get information about a group from a signal.group link
type GroupLinkInfoRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to use
	Uri     string `json:"uri,omitempty" yaml:"uri,omitempty"`         // the signald.group link
}

type GroupList struct {
	Groups       []*JsonGroupV2Info `json:"groups,omitempty" yaml:"groups,omitempty"`
	LegacyGroups []*JsonGroupInfo   `json:"legacyGroups,omitempty" yaml:"legacyGroups,omitempty"` // list of legacy (v1) groups, no longer supported (will always be empty)
}

type GroupMember struct {
	JoinedRevision int32  `json:"joined_revision,omitempty" yaml:"joined_revision,omitempty"`
	Role           string `json:"role,omitempty" yaml:"role,omitempty"` // possible values are: UNKNOWN, DEFAULT, ADMINISTRATOR and UNRECOGNIZED
	UUID           string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type GroupPendingMember struct {
	AddedByUuid string `json:"added_by_uuid,omitempty" yaml:"added_by_uuid,omitempty"`
	Role        string `json:"role,omitempty" yaml:"role,omitempty"` // possible values are: UNKNOWN, DEFAULT, ADMINISTRATOR and UNRECOGNIZED
	Timestamp   int64  `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	UUID        string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type GroupRequestingMember struct {
	Timestamp int64  `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	UUID      string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type HangupMessage struct {
	DeviceId int32  `json:"device_id,omitempty" yaml:"device_id,omitempty"`
	ID       int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Legacy   bool   `json:"legacy,omitempty" yaml:"legacy,omitempty"`
	Type     string `json:"type,omitempty" yaml:"type,omitempty"`
}

type IceUpdateMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
}

type IdentityKey struct {
	Added        int64  `json:"added,omitempty" yaml:"added,omitempty"`               // the first time this identity key was seen
	QrCodeData   string `json:"qr_code_data,omitempty" yaml:"qr_code_data,omitempty"` // base64-encoded QR code data
	SafetyNumber string `json:"safety_number,omitempty" yaml:"safety_number,omitempty"`
	TrustLevel   string `json:"trust_level,omitempty" yaml:"trust_level,omitempty"` // One of TRUSTED_UNVERIFIED, TRUSTED_VERIFIED or UNTRUSTED
}

// IdentityKeyList: a list of identity keys associated with a particular address
type IdentityKeyList struct {
	Address    *JsonAddress   `json:"address,omitempty" yaml:"address,omitempty"`
	Identities []*IdentityKey `json:"identities,omitempty" yaml:"identities,omitempty"`
}

type IncomingMessage struct {
	Account                 string           `json:"account,omitempty" yaml:"account,omitempty"`
	CallMessage             *CallMessage     `json:"call_message,omitempty" yaml:"call_message,omitempty"`
	DataMessage             *JsonDataMessage `json:"data_message,omitempty" yaml:"data_message,omitempty"`
	HasContent              bool             `json:"has_content,omitempty" yaml:"has_content,omitempty"`
	HasLegacyMessage        bool             `json:"has_legacy_message,omitempty" yaml:"has_legacy_message,omitempty"`
	ReceiptMessage          *ReceiptMessage  `json:"receipt_message,omitempty" yaml:"receipt_message,omitempty"`
	ServerDeliverTimestamp  int64            `json:"server_deliver_timestamp,omitempty" yaml:"server_deliver_timestamp,omitempty"`
	ServerGuid              string           `json:"server_guid,omitempty" yaml:"server_guid,omitempty"`
	ServerReceiverTimestamp int64            `json:"server_receiver_timestamp,omitempty" yaml:"server_receiver_timestamp,omitempty"`
	Source                  *JsonAddress     `json:"source,omitempty" yaml:"source,omitempty"`
	SourceDevice            int32            `json:"source_device,omitempty" yaml:"source_device,omitempty"`
	StoryMessage            *StoryMessage    `json:"story_message,omitempty" yaml:"story_message,omitempty"`
	SyncMessage             *JsonSyncMessage `json:"sync_message,omitempty" yaml:"sync_message,omitempty"`
	Timestamp               int64            `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	Type                    string           `json:"type,omitempty" yaml:"type,omitempty"`
	TypingMessage           *TypingMessage   `json:"typing_message,omitempty" yaml:"typing_message,omitempty"`
	UnidentifiedSender      bool             `json:"unidentified_sender,omitempty" yaml:"unidentified_sender,omitempty"`
}

// IsIdentifierRegisteredRequest: Determine whether an account identifier is registered on the Signal service.
type IsIdentifierRegisteredRequest struct {
	Request
	Account    string `json:"account,omitempty" yaml:"account,omitempty"`       // The account to use to use
	Identifier string `json:"identifier,omitempty" yaml:"identifier,omitempty"` // The UUID of an identifier to check if it is registered on Signal. This UUID is either a Phone Number Identity (PNI) or an Account Identity (ACI).
}

// JoinGroupRequest: Join a group using the a signal.group URL. Note that you must have a profile name set to join groups.
type JoinGroupRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	Uri     string `json:"uri,omitempty" yaml:"uri,omitempty"`         // The signal.group URL
}

type JsonAddress struct {
	Number string `json:"number,omitempty" yaml:"number,omitempty"` // An e164 phone number, starting with +. Currently the only available user-facing Signal identifier.
	Relay  string `json:"relay,omitempty" yaml:"relay,omitempty"`
	UUID   string `json:"uuid,omitempty" yaml:"uuid,omitempty"` // A UUID, the unique identifier for a particular Signal account.
}

// JsonAttachment: represents a file attached to a message. When sending, only `filename` is required.
type JsonAttachment struct {
	Blurhash       string `json:"blurhash,omitempty" yaml:"blurhash,omitempty"`
	Caption        string `json:"caption,omitempty" yaml:"caption,omitempty"`
	ContentType    string `json:"contentType,omitempty" yaml:"contentType,omitempty"`
	CustomFilename string `json:"customFilename,omitempty" yaml:"customFilename,omitempty"` // the original name of the file
	Digest         string `json:"digest,omitempty" yaml:"digest,omitempty"`
	Filename       string `json:"filename,omitempty" yaml:"filename,omitempty"` // when sending, the path to the local file to upload
	Height         int32  `json:"height,omitempty" yaml:"height,omitempty"`
	ID             string `json:"id,omitempty" yaml:"id,omitempty"`
	Key            string `json:"key,omitempty" yaml:"key,omitempty"`
	Size           int32  `json:"size,omitempty" yaml:"size,omitempty"`
	StoredFilename string `json:"storedFilename,omitempty" yaml:"storedFilename,omitempty"` // when receiving, the path that file has been downloaded to
	VoiceNote      bool   `json:"voiceNote,omitempty" yaml:"voiceNote,omitempty"`
	Width          int32  `json:"width,omitempty" yaml:"width,omitempty"`
}

type JsonBlockedListMessage struct {
	Addresses []*JsonAddress `json:"addresses,omitempty" yaml:"addresses,omitempty"`
	GroupIds  []string       `json:"groupIds,omitempty" yaml:"groupIds,omitempty"`
}

type JsonDataMessage struct {
	Attachments        []*JsonAttachment `json:"attachments,omitempty" yaml:"attachments,omitempty"` // files attached to the incoming message
	Body               string            `json:"body,omitempty" yaml:"body,omitempty"`               // the text body of the incoming message.
	Contacts           []*SharedContact  `json:"contacts,omitempty" yaml:"contacts,omitempty"`       // if the incoming message has a shared contact, the contact's information will be here
	EndSession         bool              `json:"endSession,omitempty" yaml:"endSession,omitempty"`
	ExpiresInSeconds   int32             `json:"expiresInSeconds,omitempty" yaml:"expiresInSeconds,omitempty"`         // the expiry timer on the incoming message. Clients should delete records of the message within this number of seconds
	Group              *JsonGroupInfo    `json:"group,omitempty" yaml:"group,omitempty"`                               // if the incoming message was sent to a v1 group, information about that group will be here
	GroupV2            *JsonGroupV2Info  `json:"groupV2,omitempty" yaml:"groupV2,omitempty"`                           // if the incoming message was sent to a v2 group, basic identifying information about that group will be here. If group information changes, JsonGroupV2Info.revision is incremented. If the group revision is higher than previously seen, a client can retrieve the group information by calling get_group.
	GroupCallUpdate    string            `json:"group_call_update,omitempty" yaml:"group_call_update,omitempty"`       // the eraId string from a group call message update
	IsExpirationUpdate bool              `json:"is_expiration_update,omitempty" yaml:"is_expiration_update,omitempty"` // whether or not this message changes the expiresInSeconds value for the whole chat. Some messages (remote deletes, reactions, etc) will have expiresInSeconds=0 even though the chat has disappearing messages enabled.
	Mentions           []*JsonMention    `json:"mentions,omitempty" yaml:"mentions,omitempty"`                         // list of mentions in the message
	Payment            *Payment          `json:"payment,omitempty" yaml:"payment,omitempty"`                           // details about the MobileCoin payment attached to the message, if present
	Previews           []*JsonPreview    `json:"previews,omitempty" yaml:"previews,omitempty"`                         // if the incoming message has a link preview, information about that preview will be here
	ProfileKeyUpdate   bool              `json:"profileKeyUpdate,omitempty" yaml:"profileKeyUpdate,omitempty"`
	Quote              *JsonQuote        `json:"quote,omitempty" yaml:"quote,omitempty"`               // if the incoming message is a quote or reply to another message, this will contain information about that message
	Reaction           *JsonReaction     `json:"reaction,omitempty" yaml:"reaction,omitempty"`         // if the message adds or removes a reaction to another message, this will indicate what change is being made
	RemoteDelete       *RemoteDelete     `json:"remoteDelete,omitempty" yaml:"remoteDelete,omitempty"` // if the inbound message is deleting a previously sent message, indicates which message should be deleted
	Sticker            *v0.JsonSticker   `json:"sticker,omitempty" yaml:"sticker,omitempty"`           // if the incoming message is a sticker, information about the sicker will be here
	StoryContext       *StoryContext     `json:"story_context,omitempty" yaml:"story_context,omitempty"`
	Timestamp          int64             `json:"timestamp,omitempty" yaml:"timestamp,omitempty"` // the timestamp that the message was sent at, according to the sender's device. This is used to uniquely identify this message for things like reactions and quotes.
	ViewOnce           bool              `json:"viewOnce,omitempty" yaml:"viewOnce,omitempty"`   // indicates the message is a view once message. View once messages typically include no body and a single image attachment. Official Signal clients will prevent the user from saving the image, and once the user has viewed the image once they will destroy the image.
}

// JsonGroupInfo: information about a legacy group
type JsonGroupInfo struct {
	AvatarId int64          `json:"avatarId,omitempty" yaml:"avatarId,omitempty"`
	GroupId  string         `json:"groupId,omitempty" yaml:"groupId,omitempty"`
	Members  []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"`
	Name     string         `json:"name,omitempty" yaml:"name,omitempty"`
	Type     string         `json:"type,omitempty" yaml:"type,omitempty"`
}

type JsonGroupJoinInfo struct {
	AddFromInviteLink    int32  `json:"addFromInviteLink,omitempty" yaml:"addFromInviteLink,omitempty"` // The access level required in order to join the group from the invite link, as an AccessControl.AccessRequired enum from the upstream Signal groups.proto file. This is UNSATISFIABLE (4) when the group link is disabled; ADMINISTRATOR (3) when the group link is enabled, but an administrator must approve new members; and ANY (1) when the group link is enabled and no approval is required. See theGroupAccessControl structure and the upstream enum ordinals.
	Description          string `json:"description,omitempty" yaml:"description,omitempty"`
	GroupID              string `json:"groupID,omitempty" yaml:"groupID,omitempty"`
	MemberCount          int32  `json:"memberCount,omitempty" yaml:"memberCount,omitempty"`
	PendingAdminApproval bool   `json:"pendingAdminApproval,omitempty" yaml:"pendingAdminApproval,omitempty"` // Whether the account is waiting for admin approval in order to be added to the group.
	Revision             int32  `json:"revision,omitempty" yaml:"revision,omitempty"`                         // The Group V2 revision. This is incremented by clients whenever they update group information, and it is often used by clients to determine if the local group state is out-of-date with the server's revision.
	Title                string `json:"title,omitempty" yaml:"title,omitempty"`
}

// JsonGroupV2Info: Information about a Signal group
type JsonGroupV2Info struct {
	AccessControl       *GroupAccessControl  `json:"accessControl,omitempty" yaml:"accessControl,omitempty"` // current access control settings for this group
	Announcements       string               `json:"announcements,omitempty" yaml:"announcements,omitempty"` // indicates if the group is an announcements group. Only admins are allowed to send messages to announcements groups. Options are UNKNOWN, ENABLED or DISABLED
	Avatar              string               `json:"avatar,omitempty" yaml:"avatar,omitempty"`               // path to the group's avatar on local disk, if available
	BannedMembers       []*BannedGroupMember `json:"banned_members,omitempty" yaml:"banned_members,omitempty"`
	Description         string               `json:"description,omitempty" yaml:"description,omitempty"`
	GroupChange         *GroupChange         `json:"group_change,omitempty" yaml:"group_change,omitempty"` // Represents a peer-to-peer group change done by a user. Will not be set if the group change signature fails verification. This is usually only set inside of incoming messages.
	ID                  string               `json:"id,omitempty" yaml:"id,omitempty"`
	InviteLink          string               `json:"inviteLink,omitempty" yaml:"inviteLink,omitempty"`     // the signal.group link, if applicable
	MemberDetail        []*GroupMember       `json:"memberDetail,omitempty" yaml:"memberDetail,omitempty"` // detailed member list
	Members             []*JsonAddress       `json:"members,omitempty" yaml:"members,omitempty"`
	PendingMemberDetail []*GroupMember       `json:"pendingMemberDetail,omitempty" yaml:"pendingMemberDetail,omitempty"` // detailed pending member list
	PendingMembers      []*JsonAddress       `json:"pendingMembers,omitempty" yaml:"pendingMembers,omitempty"`
	Removed             bool                 `json:"removed,omitempty" yaml:"removed,omitempty"` // will be set to true for incoming messages to indicate the user has been removed from the group
	RequestingMembers   []*JsonAddress       `json:"requestingMembers,omitempty" yaml:"requestingMembers,omitempty"`
	Revision            int32                `json:"revision,omitempty" yaml:"revision,omitempty"`
	Timer               int32                `json:"timer,omitempty" yaml:"timer,omitempty"`
	Title               string               `json:"title,omitempty" yaml:"title,omitempty"`
}

type JsonMention struct {
	Length int32  `json:"length,omitempty" yaml:"length,omitempty"` // The length of the mention represented in the message. Seems to always be 1 but included here in case that changes.
	Start  int32  `json:"start,omitempty" yaml:"start,omitempty"`   // The number of characters in that the mention starts at. Note that due to a quirk of how signald encodes JSON, if this value is 0 (for example if the first character in the message is the mention) the field won't show up.
	UUID   string `json:"uuid,omitempty" yaml:"uuid,omitempty"`     // The UUID of the account being mentioned
}

// JsonMessageRequestResponseMessage: Responses to message requests from unknown users or groups
type JsonMessageRequestResponseMessage struct {
	GroupId string       `json:"groupId,omitempty" yaml:"groupId,omitempty"`
	Person  *JsonAddress `json:"person,omitempty" yaml:"person,omitempty"`
	Type    string       `json:"type,omitempty" yaml:"type,omitempty"` // One of UNKNOWN, ACCEPT, DELETE, BLOCK, BLOCK_AND_DELETE, UNBLOCK_AND_ACCEPT
}

// JsonPreview: metadata about one of the links in a message
type JsonPreview struct {
	Attachment  *JsonAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty"` // an optional image file attached to the preview
	Date        int64           `json:"date,omitempty" yaml:"date,omitempty"`
	Description string          `json:"description,omitempty" yaml:"description,omitempty"`
	Title       string          `json:"title,omitempty" yaml:"title,omitempty"`
	Url         string          `json:"url,omitempty" yaml:"url,omitempty"`
}

// JsonQuote: A quote is a reply to a previous message. ID is the sent time of the message being replied to
type JsonQuote struct {
	Attachments []*v0.JsonQuotedAttachment `json:"attachments,omitempty" yaml:"attachments,omitempty"` // list of files attached to the quoted message
	Author      *JsonAddress               `json:"author,omitempty" yaml:"author,omitempty"`           // the author of the message being quoted
	ID          int64                      `json:"id,omitempty" yaml:"id,omitempty"`                   // the client timestamp of the message being quoted
	Mentions    []*JsonMention             `json:"mentions,omitempty" yaml:"mentions,omitempty"`       // list of mentions in the quoted message
	Text        string                     `json:"text,omitempty" yaml:"text,omitempty"`               // the body of the message being quoted
}

type JsonReaction struct {
	Emoji               string       `json:"emoji,omitempty" yaml:"emoji,omitempty"`                             // the emoji to react with
	Remove              bool         `json:"remove,omitempty" yaml:"remove,omitempty"`                           // set to true to remove the reaction. requires emoji be set to previously reacted emoji
	TargetAuthor        *JsonAddress `json:"targetAuthor,omitempty" yaml:"targetAuthor,omitempty"`               // the author of the message being reacted to
	TargetSentTimestamp int64        `json:"targetSentTimestamp,omitempty" yaml:"targetSentTimestamp,omitempty"` // the client timestamp of the message being reacted to
}

type JsonReadMessage struct {
	Sender    *JsonAddress `json:"sender,omitempty" yaml:"sender,omitempty"`
	Timestamp int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type JsonSendMessageResult struct {
	Address              *JsonAddress        `json:"address,omitempty" yaml:"address,omitempty"`
	IdentityFailure      string              `json:"identityFailure,omitempty" yaml:"identityFailure,omitempty"`
	NetworkFailure       bool                `json:"networkFailure,omitempty" yaml:"networkFailure,omitempty"`
	ProofRequiredFailure *ProofRequiredError `json:"proof_required_failure,omitempty" yaml:"proof_required_failure,omitempty"`
	Success              *SendSuccess        `json:"success,omitempty" yaml:"success,omitempty"`
	UnregisteredFailure  bool                `json:"unregisteredFailure,omitempty" yaml:"unregisteredFailure,omitempty"`
}

type JsonSentTranscriptMessage struct {
	Destination              *JsonAddress      `json:"destination,omitempty" yaml:"destination,omitempty"`
	ExpirationStartTimestamp int64             `json:"expirationStartTimestamp,omitempty" yaml:"expirationStartTimestamp,omitempty"`
	IsRecipientUpdate        bool              `json:"isRecipientUpdate,omitempty" yaml:"isRecipientUpdate,omitempty"`
	Message                  *JsonDataMessage  `json:"message,omitempty" yaml:"message,omitempty"`
	Story                    *StoryMessage     `json:"story,omitempty" yaml:"story,omitempty"`
	Timestamp                int64             `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	UnidentifiedStatus       map[string]string `json:"unidentifiedStatus,omitempty" yaml:"unidentifiedStatus,omitempty"`
}

type JsonSyncMessage struct {
	BlockedList            *JsonBlockedListMessage               `json:"blockedList,omitempty" yaml:"blockedList,omitempty"`
	Configuration          *v0.ConfigurationMessage              `json:"configuration,omitempty" yaml:"configuration,omitempty"`
	Contacts               *JsonAttachment                       `json:"contacts,omitempty" yaml:"contacts,omitempty"`
	ContactsComplete       bool                                  `json:"contactsComplete,omitempty" yaml:"contactsComplete,omitempty"`
	FetchType              string                                `json:"fetchType,omitempty" yaml:"fetchType,omitempty"`
	Groups                 *JsonAttachment                       `json:"groups,omitempty" yaml:"groups,omitempty"`
	MessageRequestResponse *JsonMessageRequestResponseMessage    `json:"messageRequestResponse,omitempty" yaml:"messageRequestResponse,omitempty"`
	ReadMessages           []*JsonReadMessage                    `json:"readMessages,omitempty" yaml:"readMessages,omitempty"`
	Request                string                                `json:"request,omitempty" yaml:"request,omitempty"`
	Sent                   *JsonSentTranscriptMessage            `json:"sent,omitempty" yaml:"sent,omitempty"`
	StickerPackOperations  []*v0.JsonStickerPackOperationMessage `json:"stickerPackOperations,omitempty" yaml:"stickerPackOperations,omitempty"`
	Verified               *JsonVerifiedMessage                  `json:"verified,omitempty" yaml:"verified,omitempty"`
	ViewOnceOpen           *JsonViewOnceOpenMessage              `json:"viewOnceOpen,omitempty" yaml:"viewOnceOpen,omitempty"`
}

type JsonVerifiedMessage struct {
	Destination *JsonAddress `json:"destination,omitempty" yaml:"destination,omitempty"`
	IdentityKey string       `json:"identityKey,omitempty" yaml:"identityKey,omitempty"`
	Timestamp   int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	Verified    string       `json:"verified,omitempty" yaml:"verified,omitempty"`
}

type JsonVersionMessage struct {
	Branch  string `json:"branch,omitempty" yaml:"branch,omitempty"`
	Commit  string `json:"commit,omitempty" yaml:"commit,omitempty"`
	Name    string `json:"name,omitempty" yaml:"name,omitempty"`
	Version string `json:"version,omitempty" yaml:"version,omitempty"`
}

type JsonViewOnceOpenMessage struct {
	Sender    *JsonAddress `json:"sender,omitempty" yaml:"sender,omitempty"`
	Timestamp int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type LeaveGroupRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to use
	GroupID string `json:"groupID,omitempty" yaml:"groupID,omitempty"` // The group to leave
}

type LinkedDevices struct {
	Devices []*DeviceInfo `json:"devices,omitempty" yaml:"devices,omitempty"`
}

type LinkingURI struct {
	SessionId string `json:"session_id,omitempty" yaml:"session_id,omitempty"`
	Uri       string `json:"uri,omitempty" yaml:"uri,omitempty"`
}

// ListAccountsRequest: return all local accounts
type ListAccountsRequest struct {
	Request
}

type ListContactsRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"`
	Async   bool   `json:"async,omitempty" yaml:"async,omitempty"` // return results from local store immediately, refreshing from server afterward if needed. If false (default), block until all pending profiles have been retrieved.
}

type ListGroupsRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"`
}

// ListenerState: prior attempt to indicate signald connectivity state. WebSocketConnectionState messages will be delivered at the  same time as well as in other parts of the websocket lifecycle.
type ListenerState struct {
	Connected bool `json:"connected,omitempty" yaml:"connected,omitempty"`
}

type MarkReadRequest struct {
	Request
	Account    string       `json:"account,omitempty" yaml:"account,omitempty"`       // The account to interact with
	Timestamps []int64      `json:"timestamps,omitempty" yaml:"timestamps,omitempty"` // List of messages to mark as read
	To         *JsonAddress `json:"to,omitempty" yaml:"to,omitempty"`                 // The address that sent the message being marked as read
	When       int64        `json:"when,omitempty" yaml:"when,omitempty"`
}

type OfferMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
	Type   string `json:"type,omitempty" yaml:"type,omitempty"`
}

type PagingData struct {
	HasMorePages     bool  `json:"has_more_pages,omitempty" yaml:"has_more_pages,omitempty"`
	NextPageRevision int32 `json:"next_page_revision,omitempty" yaml:"next_page_revision,omitempty"`
}

// Payment: details about a MobileCoin payment
type Payment struct {
	Note    string `json:"note,omitempty" yaml:"note,omitempty"`       // note attached to the payment
	Receipt string `json:"receipt,omitempty" yaml:"receipt,omitempty"` // base64 encoded payment receipt data. This is a protobuf value which can be decoded as the Receipt object described in https://github.com/mobilecoinfoundation/mobilecoin/blob/master/api/proto/external.proto
}

// Profile: Information about a Signal user
type Profile struct {
	About             string        `json:"about,omitempty" yaml:"about,omitempty"`
	Address           *JsonAddress  `json:"address,omitempty" yaml:"address,omitempty"`
	Avatar            string        `json:"avatar,omitempty" yaml:"avatar,omitempty"` // path to avatar on local disk
	Capabilities      *Capabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`
	Color             string        `json:"color,omitempty" yaml:"color,omitempty"`               // color of the chat with this user
	ContactName       string        `json:"contact_name,omitempty" yaml:"contact_name,omitempty"` // The user's name from local contact names
	Emoji             string        `json:"emoji,omitempty" yaml:"emoji,omitempty"`
	ExpirationTime    int32         `json:"expiration_time,omitempty" yaml:"expiration_time,omitempty"`
	InboxPosition     int32         `json:"inbox_position,omitempty" yaml:"inbox_position,omitempty"`
	MobilecoinAddress string        `json:"mobilecoin_address,omitempty" yaml:"mobilecoin_address,omitempty"` // *base64-encoded* mobilecoin address. Note that this is not the traditional MobileCoin address encoding. Clients are responsible for converting between MobileCoin's custom base58 on the user-facing side and base64 encoding on the signald side. If unset, null or an empty string, will empty the profile payment address
	Name              string        `json:"name,omitempty" yaml:"name,omitempty"`                             // The user's name from local contact names if available, or if not in contact list their Signal profile name
	ProfileName       string        `json:"profile_name,omitempty" yaml:"profile_name,omitempty"`             // The user's Signal profile name
	VisibleBadgeIds   []string      `json:"visible_badge_ids,omitempty" yaml:"visible_badge_ids,omitempty"`   // currently unclear how these work, as they are not available in the production Signal apps
}

type ProfileList struct {
	Profiles []*Profile `json:"profiles,omitempty" yaml:"profiles,omitempty"`
}

// ReactRequest: react to a previous message
type ReactRequest struct {
	Request
	Members          []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"` // Optionally set to a sub-set of group members. Ignored if recipientGroupId isn't specified
	Reaction         *JsonReaction  `json:"reaction,omitempty" yaml:"reaction,omitempty"`
	RecipientAddress *JsonAddress   `json:"recipientAddress,omitempty" yaml:"recipientAddress,omitempty"`
	RecipientGroupID string         `json:"recipientGroupId,omitempty" yaml:"recipientGroupId,omitempty"`
	Timestamp        int64          `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	Username         string         `json:"username,omitempty" yaml:"username,omitempty"`
}

type ReceiptMessage struct {
	Timestamps []int64 `json:"timestamps,omitempty" yaml:"timestamps,omitempty"`
	Type       string  `json:"type,omitempty" yaml:"type,omitempty"` // options: UNKNOWN, DELIVERY, READ, VIEWED
	When       int64   `json:"when,omitempty" yaml:"when,omitempty"`
}

// RefuseMembershipRequest: deny a request to join a group
type RefuseMembershipRequest struct {
	Request
	Account string         `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	AlsoBan bool           `json:"also_ban,omitempty" yaml:"also_ban,omitempty"`
	GroupId string         `json:"group_id,omitempty" yaml:"group_id,omitempty"`
	Members []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"` // list of requesting members to refuse
}

// RegisterRequest: begin the account registration process by requesting a phone number verification code. when the code is received, submit it with a verify request
type RegisterRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // the e164 phone number to register with
	Captcha string `json:"captcha,omitempty" yaml:"captcha,omitempty"` // See https://signald.org/articles/captcha/
	Server  string `json:"server,omitempty" yaml:"server,omitempty"`   // The identifier of the server to use. Leave blank for default (usually Signal production servers but configurable at build time)
	Voice   bool   `json:"voice,omitempty" yaml:"voice,omitempty"`     // set to true to request a voice call instead of an SMS for verification
}

// RemoteConfig: A remote config (feature flag) entry.
type RemoteConfig struct {
	Name  string `json:"name,omitempty" yaml:"name,omitempty"`   // The name of this remote config entry. These names may be prefixed with the platform type ("android.", "ios.", "desktop.", etc.) Typically, clients only handle the relevant configs for its platform, hardcoding the names it cares about handling and ignoring the rest.
	Value string `json:"value,omitempty" yaml:"value,omitempty"` // The value for this remote config entry. Even though this is a string, it could be a boolean as a string, an integer/long value, a comma-delimited list, etc. Clients usually consume this by hardcoding the feature flagsit should track in the app and assuming that the server will send the type that the client expects. If an unexpected type occurs, it falls back to a default value.
}

type RemoteConfigList struct {
	Config []*RemoteConfig `json:"config,omitempty" yaml:"config,omitempty"`
}

// RemoteConfigRequest: Retrieves the remote config (feature flags) from the server.
type RemoteConfigRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to use to retrieve the remote config
}

type RemoteDelete struct {
	TargetSentTimestamp int64 `json:"target_sent_timestamp,omitempty" yaml:"target_sent_timestamp,omitempty"`
}

// RemoteDeleteRequest: delete a message previously sent
type RemoteDeleteRequest struct {
	Request
	Account   string         `json:"account,omitempty" yaml:"account,omitempty"` // the account to use
	Address   *JsonAddress   `json:"address,omitempty" yaml:"address,omitempty"` // the address to send the delete message to. should match address the message to be deleted was sent to. required if group is not set.
	Group     string         `json:"group,omitempty" yaml:"group,omitempty"`     // the group to send the delete message to. should match group the message to be deleted was sent to. required if address is not set.
	Members   []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"` // Optionally set to a sub-set of group members. Ignored if group isn't specified
	Timestamp int64          `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

// RemoveLinkedDeviceRequest: Remove a linked device from the Signal account. Only allowed when the local device id is 1
type RemoveLinkedDeviceRequest struct {
	Request
	Account  string `json:"account,omitempty" yaml:"account,omitempty"`   // The account to interact with
	DeviceId int64  `json:"deviceId,omitempty" yaml:"deviceId,omitempty"` // the ID of the device to unlink
}

type RemoveServerRequest struct {
	Request
	UUID string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

// RequestSyncRequest: Request other devices on the account send us their group list, syncable config and contact list.
type RequestSyncRequest struct {
	Request
	Account       string `json:"account,omitempty" yaml:"account,omitempty"`             // The account to use
	Blocked       bool   `json:"blocked,omitempty" yaml:"blocked,omitempty"`             // request block list sync (default true)
	Configuration bool   `json:"configuration,omitempty" yaml:"configuration,omitempty"` // request configuration sync (default true)
	Contacts      bool   `json:"contacts,omitempty" yaml:"contacts,omitempty"`           // request contact sync (default true)
	Groups        bool   `json:"groups,omitempty" yaml:"groups,omitempty"`               // request group sync (default true)
	Keys          bool   `json:"keys,omitempty" yaml:"keys,omitempty"`                   // request storage service keys
}

// ResetSessionRequest: reset a session with a particular user
type ResetSessionRequest struct {
	Request
	Account   string       `json:"account,omitempty" yaml:"account,omitempty"` // The account to use
	Address   *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"` // the user to reset session with
	Timestamp int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

// ResolveAddressRequest: Resolve a partial JsonAddress with only a number or UUID to one with both. Anywhere that signald accepts a JsonAddress will except a partial, this is a convenience function for client authors, mostly because signald doesn't resolve all the partials it returns.
type ResolveAddressRequest struct {
	Request
	Account string       `json:"account,omitempty" yaml:"account,omitempty"` // The signal account to use
	Partial *JsonAddress `json:"partial,omitempty" yaml:"partial,omitempty"` // The partial address, missing fields
}

// SendPaymentRequest: send a mobilecoin payment
type SendPaymentRequest struct {
	Request
	Account string       `json:"account,omitempty" yaml:"account,omitempty"` // the account to use
	Address *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"` // the address to send the payment message to
	Payment *Payment     `json:"payment,omitempty" yaml:"payment,omitempty"`
	When    int64        `json:"when,omitempty" yaml:"when,omitempty"`
}

type SendRequest struct {
	Request
	Account          string            `json:"account,omitempty" yaml:"account,omitempty"`
	Attachments      []*JsonAttachment `json:"attachments,omitempty" yaml:"attachments,omitempty"`
	Members          []*JsonAddress    `json:"members,omitempty" yaml:"members,omitempty"` // Optionally set to a sub-set of group members. Ignored if recipientGroupId isn't specified
	Mentions         []*JsonMention    `json:"mentions,omitempty" yaml:"mentions,omitempty"`
	MessageBody      string            `json:"messageBody,omitempty" yaml:"messageBody,omitempty"`
	Previews         []*JsonPreview    `json:"previews,omitempty" yaml:"previews,omitempty"`
	Quote            *JsonQuote        `json:"quote,omitempty" yaml:"quote,omitempty"`
	RecipientAddress *JsonAddress      `json:"recipientAddress,omitempty" yaml:"recipientAddress,omitempty"`
	RecipientGroupID string            `json:"recipientGroupId,omitempty" yaml:"recipientGroupId,omitempty"`
	Timestamp        int64             `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	Username         string            `json:"username,omitempty" yaml:"username,omitempty"`
}

type SendResponse struct {
	Results   []*JsonSendMessageResult `json:"results,omitempty" yaml:"results,omitempty"`
	Timestamp int64                    `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type SendSuccess struct {
	Devices      []int32 `json:"devices,omitempty" yaml:"devices,omitempty"`
	Duration     int64   `json:"duration,omitempty" yaml:"duration,omitempty"`
	NeedsSync    bool    `json:"needsSync,omitempty" yaml:"needsSync,omitempty"`
	Unidentified bool    `json:"unidentified,omitempty" yaml:"unidentified,omitempty"`
}

// SendSyncMessageRequest: Sends a sync message to the account's devices
type SendSyncMessageRequest struct {
	Request
	Account                string                             `json:"account,omitempty" yaml:"account,omitempty"`
	MessageRequestResponse *JsonMessageRequestResponseMessage `json:"message_request_response,omitempty" yaml:"message_request_response,omitempty"` // This can be set to indicate to other devices about a response to an incoming message request from an unknown user or group. Warning: Using the BLOCK and BLOCK_AND_DELETE options relies on other devices to do the blocking, and it does not make you leave the group!
	ViewOnceOpenMessage    *JsonViewOnceOpenMessage           `json:"view_once_open_message,omitempty" yaml:"view_once_open_message,omitempty"`     // This can be set to indicate to other devices about having viewed a view-once message.
}

// Server: a Signal server
type Server struct {
	Ca                     string       `json:"ca,omitempty" yaml:"ca,omitempty"` // base64 encoded trust store, password must be 'whisper'
	CdnUrls                []*ServerCDN `json:"cdn_urls,omitempty" yaml:"cdn_urls,omitempty"`
	CdsMrenclave           string       `json:"cds_mrenclave,omitempty" yaml:"cds_mrenclave,omitempty"`
	ContactDiscoveryUrl    string       `json:"contact_discovery_url,omitempty" yaml:"contact_discovery_url,omitempty"`
	IasCa                  string       `json:"ias_ca,omitempty" yaml:"ias_ca,omitempty"` // base64 encoded trust store, password must be 'whisper'
	KeyBackupMrenclave     string       `json:"key_backup_mrenclave,omitempty" yaml:"key_backup_mrenclave,omitempty"`
	KeyBackupServiceId     string       `json:"key_backup_service_id,omitempty" yaml:"key_backup_service_id,omitempty"` // base64 encoded
	KeyBackupServiceName   string       `json:"key_backup_service_name,omitempty" yaml:"key_backup_service_name,omitempty"`
	KeyBackupUrl           string       `json:"key_backup_url,omitempty" yaml:"key_backup_url,omitempty"`
	Proxy                  string       `json:"proxy,omitempty" yaml:"proxy,omitempty"`
	ServiceUrl             string       `json:"service_url,omitempty" yaml:"service_url,omitempty"`
	StorageUrl             string       `json:"storage_url,omitempty" yaml:"storage_url,omitempty"`
	UnidentifiedSenderRoot string       `json:"unidentified_sender_root,omitempty" yaml:"unidentified_sender_root,omitempty"` // base64 encoded
	UUID                   string       `json:"uuid,omitempty" yaml:"uuid,omitempty"`                                         // A unique identifier for the server, referenced when adding accounts. Must be a valid UUID. Will be generated if not specified when creating.
	ZkParam                string       `json:"zk_param,omitempty" yaml:"zk_param,omitempty"`                                 // base64 encoded ZKGROUP_SERVER_PUBLIC_PARAMS value
}

type ServerCDN struct {
	Number int32  `json:"number,omitempty" yaml:"number,omitempty"`
	Url    string `json:"url,omitempty" yaml:"url,omitempty"`
}

type ServerList struct {
	Servers []*Server `json:"servers,omitempty" yaml:"servers,omitempty"`
}

// SetDeviceNameRequest: set this device's name. This will show up on the mobile device on the same account under settings -> linked devices
type SetDeviceNameRequest struct {
	Request
	Account    string `json:"account,omitempty" yaml:"account,omitempty"`         // The account to set the device name of
	DeviceName string `json:"device_name,omitempty" yaml:"device_name,omitempty"` // The device name
}

// SetExpirationRequest: Set the message expiration timer for a thread. Expiration must be specified in seconds, set to 0 to disable timer
type SetExpirationRequest struct {
	Request
	Account    string       `json:"account,omitempty" yaml:"account,omitempty"` // The account to use
	Address    *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"`
	Expiration int32        `json:"expiration,omitempty" yaml:"expiration,omitempty"`
	Group      string       `json:"group,omitempty" yaml:"group,omitempty"`
}

type SetProfile struct {
	Request
	About             string   `json:"about,omitempty" yaml:"about,omitempty"`                           // Change the 'about' profile field
	Account           string   `json:"account,omitempty" yaml:"account,omitempty"`                       // The phone number of the account to use
	AvatarFile        string   `json:"avatarFile,omitempty" yaml:"avatarFile,omitempty"`                 // Path to new profile avatar file. If unset or null, unset the profile avatar
	Emoji             string   `json:"emoji,omitempty" yaml:"emoji,omitempty"`                           // Change the profile emoji
	MobilecoinAddress string   `json:"mobilecoin_address,omitempty" yaml:"mobilecoin_address,omitempty"` // Change the profile payment address. Payment address must be a *base64-encoded* MobileCoin address. Note that this is not the traditional MobileCoin address encoding, which is custom. Clients are responsible for converting between MobileCoin's custom base58 on the user-facing side and base64 encoding on the signald side.
	Name              string   `json:"name,omitempty" yaml:"name,omitempty"`                             // Change the profile name
	VisibleBadgeIds   []string `json:"visible_badge_ids,omitempty" yaml:"visible_badge_ids,omitempty"`   // configure visible badge IDs
}

type SharedContact struct {
	Address      []*SharedContactAddress `json:"address,omitempty" yaml:"address,omitempty"`           // the physical addresses of the shared contact
	Avatar       *SharedContactAvatar    `json:"avatar,omitempty" yaml:"avatar,omitempty"`             // the profile picture/avatar of the shared contact
	Email        []*SharedContactEmail   `json:"email,omitempty" yaml:"email,omitempty"`               // the email addresses of the shared contact
	Name         *SharedContactName      `json:"name,omitempty" yaml:"name,omitempty"`                 // the name of the shared contact
	Organization string                  `json:"organization,omitempty" yaml:"organization,omitempty"` // the organization (e.g. workplace) of the shared contact
	Phone        []*SharedContactPhone   `json:"phone,omitempty" yaml:"phone,omitempty"`               // the phone numbers of the shared contact
}

type SharedContactAddress struct {
	City         string `json:"city,omitempty" yaml:"city,omitempty"`
	Country      string `json:"country,omitempty" yaml:"country,omitempty"`
	Label        string `json:"label,omitempty" yaml:"label,omitempty"`
	Neighborhood string `json:"neighborhood,omitempty" yaml:"neighborhood,omitempty"`
	Pobox        string `json:"pobox,omitempty" yaml:"pobox,omitempty"`
	Postcode     string `json:"postcode,omitempty" yaml:"postcode,omitempty"`
	Region       string `json:"region,omitempty" yaml:"region,omitempty"`
	Street       string `json:"street,omitempty" yaml:"street,omitempty"`
	Type         string `json:"type,omitempty" yaml:"type,omitempty"` // the type of address (options: HOME, WORK, CUSTOM)
}

type SharedContactAvatar struct {
	Attachment *JsonAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty"`
	IsProfile  bool            `json:"is_profile,omitempty" yaml:"is_profile,omitempty"`
}

type SharedContactEmail struct {
	Label string `json:"label,omitempty" yaml:"label,omitempty"` // the type label when type is CUSTOM
	Type  string `json:"type,omitempty" yaml:"type,omitempty"`   // the type of email (options: HOME, WORK, MOBILE, CUSTOM)
	Value string `json:"value,omitempty" yaml:"value,omitempty"` // the email address
}

type SharedContactName struct {
	Display string `json:"display,omitempty" yaml:"display,omitempty"` // the full name that should be displayed
	Family  string `json:"family,omitempty" yaml:"family,omitempty"`   // family name (surname)
	Given   string `json:"given,omitempty" yaml:"given,omitempty"`     // given name
	Middle  string `json:"middle,omitempty" yaml:"middle,omitempty"`   // middle name
	Prefix  string `json:"prefix,omitempty" yaml:"prefix,omitempty"`
	Suffix  string `json:"suffix,omitempty" yaml:"suffix,omitempty"`
}

type SharedContactPhone struct {
	Label string `json:"label,omitempty" yaml:"label,omitempty"` // the type label when type is CUSTOM
	Type  string `json:"type,omitempty" yaml:"type,omitempty"`   // the type of phone (options: HOME, WORK, MOBILE, CUSTOM)
	Value string `json:"value,omitempty" yaml:"value,omitempty"` // the phone number
}

// StorageChange: Broadcast to subscribed clients when there is a state change from the storage service
type StorageChange struct {
	Version int64 `json:"version,omitempty" yaml:"version,omitempty"` // Seems to behave like the group version numbers and increments every time the state changes
}

type StoryContext struct {
	Author        string `json:"author,omitempty" yaml:"author,omitempty"`
	SentTimestamp int64  `json:"sent_timestamp,omitempty" yaml:"sent_timestamp,omitempty"`
}

type StoryMessage struct {
	AllowReplies bool             `json:"allow_replies,omitempty" yaml:"allow_replies,omitempty"`
	File         *JsonAttachment  `json:"file,omitempty" yaml:"file,omitempty"`
	Group        *JsonGroupV2Info `json:"group,omitempty" yaml:"group,omitempty"`
	Text         *TextAttachment  `json:"text,omitempty" yaml:"text,omitempty"`
}

type SubmitChallengeRequest struct {
	Request
	Account      string `json:"account,omitempty" yaml:"account,omitempty"`
	CaptchaToken string `json:"captcha_token,omitempty" yaml:"captcha_token,omitempty"`
	Challenge    string `json:"challenge,omitempty" yaml:"challenge,omitempty"`
}

// SubscribeRequest: receive incoming messages. After making a subscribe request, incoming messages will be sent to the client encoded as ClientMessageWrapper. Send an unsubscribe request or disconnect from the socket to stop receiving messages.
type SubscribeRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to subscribe to incoming message for
}

type TextAttachment struct {
	BackgroundColor     string       `json:"background_color,omitempty" yaml:"background_color,omitempty"`
	BackgroundGradient  *Gradient    `json:"background_gradient,omitempty" yaml:"background_gradient,omitempty"`
	Preview             *JsonPreview `json:"preview,omitempty" yaml:"preview,omitempty"`
	Style               string       `json:"style,omitempty" yaml:"style,omitempty"`
	Text                string       `json:"text,omitempty" yaml:"text,omitempty"`
	TextBackgroundColor string       `json:"text_background_color,omitempty" yaml:"text_background_color,omitempty"`
	TextForegroundColor string       `json:"text_foreground_color,omitempty" yaml:"text_foreground_color,omitempty"`
}

// TrustRequest: Trust another user's safety number using either the QR code data or the safety number text
type TrustRequest struct {
	Request
	Account      string       `json:"account,omitempty" yaml:"account,omitempty"`             // The account to interact with
	Address      *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"`             // The user to query identity keys for
	QrCodeData   string       `json:"qr_code_data,omitempty" yaml:"qr_code_data,omitempty"`   // base64-encoded QR code data. required if safety_number is absent
	SafetyNumber string       `json:"safety_number,omitempty" yaml:"safety_number,omitempty"` // required if qr_code_data is absent
	TrustLevel   string       `json:"trust_level,omitempty" yaml:"trust_level,omitempty"`     // One of TRUSTED_UNVERIFIED, TRUSTED_VERIFIED or UNTRUSTED. Default is TRUSTED_VERIFIED
}

type TypingMessage struct {
	Action    string `json:"action,omitempty" yaml:"action,omitempty"`
	GroupId   string `json:"group_id,omitempty" yaml:"group_id,omitempty"`
	Timestamp int64  `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

// TypingRequest: send a typing started or stopped message
type TypingRequest struct {
	Request
	Account string       `json:"account,omitempty" yaml:"account,omitempty"` // The account to use
	Address *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"`
	Group   string       `json:"group,omitempty" yaml:"group,omitempty"`
	Typing  bool         `json:"typing,omitempty" yaml:"typing,omitempty"`
	When    int64        `json:"when,omitempty" yaml:"when,omitempty"`
}

// UnbanUserRequest: Unbans users from a group.
type UnbanUserRequest struct {
	Request
	Account string         `json:"account,omitempty" yaml:"account,omitempty"` // The account to interact with
	GroupId string         `json:"group_id,omitempty" yaml:"group_id,omitempty"`
	Users   []*JsonAddress `json:"users,omitempty" yaml:"users,omitempty"` // List of users to unban
}

// UnsubscribeRequest: See subscribe for more info
type UnsubscribeRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // The account to unsubscribe from
}

// UpdateContactRequest: update information about a local contact
type UpdateContactRequest struct {
	Request
	Account       string       `json:"account,omitempty" yaml:"account,omitempty"`
	Address       *JsonAddress `json:"address,omitempty" yaml:"address,omitempty"`
	Color         string       `json:"color,omitempty" yaml:"color,omitempty"`
	InboxPosition int32        `json:"inbox_position,omitempty" yaml:"inbox_position,omitempty"`
	Name          string       `json:"name,omitempty" yaml:"name,omitempty"`
}

// UpdateGroupRequest: modify a group. Note that only one modification action may be performed at once
type UpdateGroupRequest struct {
	Request
	Account             string              `json:"account,omitempty" yaml:"account,omitempty"` // The identifier of the account to interact with
	AddMembers          []*JsonAddress      `json:"addMembers,omitempty" yaml:"addMembers,omitempty"`
	Announcements       string              `json:"announcements,omitempty" yaml:"announcements,omitempty"` // ENABLED to only allow admins to post messages, DISABLED to allow anyone to post
	Avatar              string              `json:"avatar,omitempty" yaml:"avatar,omitempty"`
	Description         string              `json:"description,omitempty" yaml:"description,omitempty"` // A new group description. Set to empty string to remove an existing description.
	GroupID             string              `json:"groupID,omitempty" yaml:"groupID,omitempty"`         // the ID of the group to update
	RemoveMembers       []*JsonAddress      `json:"removeMembers,omitempty" yaml:"removeMembers,omitempty"`
	ResetLink           bool                `json:"resetLink,omitempty" yaml:"resetLink,omitempty"` // regenerate the group link password, invalidating the old one
	Title               string              `json:"title,omitempty" yaml:"title,omitempty"`
	UpdateAccessControl *GroupAccessControl `json:"updateAccessControl,omitempty" yaml:"updateAccessControl,omitempty"` // note that only one of the access controls may be updated per request
	UpdateRole          *GroupMember        `json:"updateRole,omitempty" yaml:"updateRole,omitempty"`
	UpdateTimer         int32               `json:"updateTimer,omitempty" yaml:"updateTimer,omitempty"` // update the group timer.
}

// VerifyRequest: verify an account's phone number with a code after registering, completing the account creation process
type VerifyRequest struct {
	Request
	Account string `json:"account,omitempty" yaml:"account,omitempty"` // the e164 phone number being verified
	Code    string `json:"code,omitempty" yaml:"code,omitempty"`       // the verification code, dash (-) optional
}

type VersionRequest struct {
	Request
}

// WaitForScanRequest: An optional part of the linking process. Intended to be called after displaying the QR code, will return quickly after the user scans the QR code. finish_link must be called after wait_for_scan returns a non-error
type WaitForScanRequest struct {
	Request
	SessionId string `json:"session_id,omitempty" yaml:"session_id,omitempty"`
}

// WebSocketConnectionState: indicates when the websocket connection state to the signal server has changed
type WebSocketConnectionState struct {
	Socket string `json:"socket,omitempty" yaml:"socket,omitempty"` // One of: UNIDENTIFIED, IDENTIFIED
	State  string `json:"state,omitempty" yaml:"state,omitempty"`   // One of: DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING, DISCONNECTING, AUTHENTICATION_FAILED, FAILED
}
