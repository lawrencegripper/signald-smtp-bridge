package v0

// DO NOT EDIT: this file is automatically generated by ./tools/generator in this repo

type Request struct {
	ID      string `json:"id" yaml:"id"`
	Version string `json:"version" yaml:"version"`
	Type    string `json:"type" yaml:"type"`
}

type AnswerMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
}

type BusyMessage struct {
	ID int64 `json:"id,omitempty" yaml:"id,omitempty"`
}

type ConfigurationMessage struct {
	LinkPreviews                   *Optional `json:"linkPreviews,omitempty" yaml:"linkPreviews,omitempty"`
	ReadReceipts                   *Optional `json:"readReceipts,omitempty" yaml:"readReceipts,omitempty"`
	TypingIndicators               *Optional `json:"typingIndicators,omitempty" yaml:"typingIndicators,omitempty"`
	UnidentifiedDeliveryIndicators *Optional `json:"unidentifiedDeliveryIndicators,omitempty" yaml:"unidentifiedDeliveryIndicators,omitempty"`
}

// GroupAccessControl: group access control settings. Options for each controlled action are: UNKNOWN, ANY, MEMBER, ADMINISTRATOR, UNSATISFIABLE and UNRECOGNIZED
type GroupAccessControl struct {
	Attributes string `json:"attributes,omitempty" yaml:"attributes,omitempty"` // who can edit group info
	Link       string `json:"link,omitempty" yaml:"link,omitempty"`             // UNSATISFIABLE when the group link is disabled, ADMINISTRATOR when the group link is enabled but an administrator must approve new members, ANY when the group link is enabled and no approval is required
	Members    string `json:"members,omitempty" yaml:"members,omitempty"`       // who can add members
}

type GroupMember struct {
	JoinedRevision int32  `json:"joined_revision,omitempty" yaml:"joined_revision,omitempty"`
	Role           string `json:"role,omitempty" yaml:"role,omitempty"` // possible values are: UNKNOWN, DEFAULT, ADMINISTRATOR and UNRECOGNIZED
	UUID           string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type HangupMessage struct {
	DeviceId int32 `json:"deviceId,omitempty" yaml:"deviceId,omitempty"`
	ID       int64 `json:"id,omitempty" yaml:"id,omitempty"`
	Legacy   bool  `json:"legacy,omitempty" yaml:"legacy,omitempty"`
	Type     *Type `json:"type,omitempty" yaml:"type,omitempty"`
}

type IceUpdateMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
}

type JsonAccount struct {
	DeviceId   int32  `json:"deviceId,omitempty" yaml:"deviceId,omitempty"`
	Filename   string `json:"filename,omitempty" yaml:"filename,omitempty"`
	HasKeys    bool   `json:"has_keys,omitempty" yaml:"has_keys,omitempty"`
	Registered bool   `json:"registered,omitempty" yaml:"registered,omitempty"`
	Subscribed bool   `json:"subscribed,omitempty" yaml:"subscribed,omitempty"`
	Username   string `json:"username,omitempty" yaml:"username,omitempty"`
	UUID       string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type JsonAccountList struct {
	Accounts []*JsonAccount `json:"accounts,omitempty" yaml:"accounts,omitempty"`
}

type JsonAddress struct {
	Number string `json:"number,omitempty" yaml:"number,omitempty"`
	Relay  string `json:"relay,omitempty" yaml:"relay,omitempty"`
	UUID   string `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type JsonAttachment struct {
	Blurhash       string `json:"blurhash,omitempty" yaml:"blurhash,omitempty"`
	Caption        string `json:"caption,omitempty" yaml:"caption,omitempty"`
	ContentType    string `json:"contentType,omitempty" yaml:"contentType,omitempty"`
	CustomFilename string `json:"customFilename,omitempty" yaml:"customFilename,omitempty"`
	Digest         string `json:"digest,omitempty" yaml:"digest,omitempty"`
	Filename       string `json:"filename,omitempty" yaml:"filename,omitempty"`
	Height         int32  `json:"height,omitempty" yaml:"height,omitempty"`
	ID             string `json:"id,omitempty" yaml:"id,omitempty"`
	Key            string `json:"key,omitempty" yaml:"key,omitempty"`
	Size           int32  `json:"size,omitempty" yaml:"size,omitempty"`
	StoredFilename string `json:"storedFilename,omitempty" yaml:"storedFilename,omitempty"`
	VoiceNote      bool   `json:"voiceNote,omitempty" yaml:"voiceNote,omitempty"`
	Width          int32  `json:"width,omitempty" yaml:"width,omitempty"`
}

type JsonBlockedListMessage struct {
	Addresses []*JsonAddress `json:"addresses,omitempty" yaml:"addresses,omitempty"`
	GroupIds  []string       `json:"groupIds,omitempty" yaml:"groupIds,omitempty"`
}

type JsonCallMessage struct {
	AnswerMessage       *AnswerMessage      `json:"answerMessage,omitempty" yaml:"answerMessage,omitempty"`
	BusyMessage         *BusyMessage        `json:"busyMessage,omitempty" yaml:"busyMessage,omitempty"`
	DestinationDeviceId int32               `json:"destinationDeviceId,omitempty" yaml:"destinationDeviceId,omitempty"`
	HangupMessage       *HangupMessage      `json:"hangupMessage,omitempty" yaml:"hangupMessage,omitempty"`
	IceUpdateMessages   []*IceUpdateMessage `json:"iceUpdateMessages,omitempty" yaml:"iceUpdateMessages,omitempty"`
	IsMultiRing         bool                `json:"isMultiRing,omitempty" yaml:"isMultiRing,omitempty"`
	OfferMessage        *OfferMessage       `json:"offerMessage,omitempty" yaml:"offerMessage,omitempty"`
}

type JsonDataMessage struct {
	Attachments      []*JsonAttachment `json:"attachments,omitempty" yaml:"attachments,omitempty"` // files attached to the incoming message
	Body             string            `json:"body,omitempty" yaml:"body,omitempty"`               // the text body of the incoming message.
	Contacts         []*SharedContact  `json:"contacts,omitempty" yaml:"contacts,omitempty"`       // if the incoming message has a shared contact, the contact's information will be here
	EndSession       bool              `json:"endSession,omitempty" yaml:"endSession,omitempty"`
	ExpiresInSeconds int32             `json:"expiresInSeconds,omitempty" yaml:"expiresInSeconds,omitempty"` // the expiry timer on the incoming message. Clients should delete records of the message within this number of seconds
	Group            *JsonGroupInfo    `json:"group,omitempty" yaml:"group,omitempty"`                       // if the incoming message was sent to a v1 group, information about that group will be here
	GroupV2          *JsonGroupV2Info  `json:"groupV2,omitempty" yaml:"groupV2,omitempty"`                   // is the incoming message was sent to a v2 group, basic identifying information about that group will be here. For full information, use list_groups
	Mentions         []*JsonMention    `json:"mentions,omitempty" yaml:"mentions,omitempty"`                 // list of mentions in the message
	Previews         []*JsonPreview    `json:"previews,omitempty" yaml:"previews,omitempty"`                 // if the incoming message has a link preview, information about that preview will be here
	ProfileKeyUpdate bool              `json:"profileKeyUpdate,omitempty" yaml:"profileKeyUpdate,omitempty"`
	Quote            *JsonQuote        `json:"quote,omitempty" yaml:"quote,omitempty"`               // if the incoming message is a quote or reply to another message, this will contain information about that message
	Reaction         *JsonReaction     `json:"reaction,omitempty" yaml:"reaction,omitempty"`         // if the message adds or removes a reaction to another message, this will indicate what change is being made
	RemoteDelete     *RemoteDelete     `json:"remoteDelete,omitempty" yaml:"remoteDelete,omitempty"` // if the inbound message is deleting a previously sent message, indicates which message should be deleted
	Sticker          *JsonSticker      `json:"sticker,omitempty" yaml:"sticker,omitempty"`           // if the incoming message is a sticker, information about the sicker will be here
	Timestamp        int64             `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`       // the timestamp that the message was sent at, according to the sender's device. This is used to uniquely identify this message for things like reactions and quotes.
	ViewOnce         bool              `json:"viewOnce,omitempty" yaml:"viewOnce,omitempty"`         // indicates the message is a view once message. View once messages typically include no body and a single image attachment. Official Signal clients will prevent the user from saving the image, and once the user has viewed the image once they will destroy the image.
}

type JsonGroupInfo struct {
	AvatarId int64          `json:"avatarId,omitempty" yaml:"avatarId,omitempty"`
	GroupId  string         `json:"groupId,omitempty" yaml:"groupId,omitempty"`
	Members  []*JsonAddress `json:"members,omitempty" yaml:"members,omitempty"`
	Name     string         `json:"name,omitempty" yaml:"name,omitempty"`
	Type     string         `json:"type,omitempty" yaml:"type,omitempty"`
}

type JsonGroupV2Info struct {
	AccessControl       *GroupAccessControl `json:"accessControl,omitempty" yaml:"accessControl,omitempty"` // current access control settings for this group
	Avatar              string              `json:"avatar,omitempty" yaml:"avatar,omitempty"`               // path to the group's avatar on local disk, if available
	Description         string              `json:"description,omitempty" yaml:"description,omitempty"`
	ID                  string              `json:"id,omitempty" yaml:"id,omitempty"`
	InviteLink          string              `json:"inviteLink,omitempty" yaml:"inviteLink,omitempty"`     // the signal.group link, if applicable
	MemberDetail        []*GroupMember      `json:"memberDetail,omitempty" yaml:"memberDetail,omitempty"` // detailed member list
	Members             []*JsonAddress      `json:"members,omitempty" yaml:"members,omitempty"`
	PendingMemberDetail []*GroupMember      `json:"pendingMemberDetail,omitempty" yaml:"pendingMemberDetail,omitempty"` // detailed pending member list
	PendingMembers      []*JsonAddress      `json:"pendingMembers,omitempty" yaml:"pendingMembers,omitempty"`
	RequestingMembers   []*JsonAddress      `json:"requestingMembers,omitempty" yaml:"requestingMembers,omitempty"`
	Revision            int32               `json:"revision,omitempty" yaml:"revision,omitempty"`
	Timer               int32               `json:"timer,omitempty" yaml:"timer,omitempty"`
	Title               string              `json:"title,omitempty" yaml:"title,omitempty"`
}

type JsonMention struct {
	Length int32  `json:"length,omitempty" yaml:"length,omitempty"` // The length of the mention represented in the message. Seems to always be 1 but included here in case that changes.
	Start  int32  `json:"start,omitempty" yaml:"start,omitempty"`   // The number of characters in that the mention starts at. Note that due to a quirk of how signald encodes JSON, if this value is 0 (for example if the first character in the message is the mention) the field won't show up.
	UUID   string `json:"uuid,omitempty" yaml:"uuid,omitempty"`     // The UUID of the account being mentioned
}

type JsonMessageEnvelope struct {
	CallMessage              *JsonCallMessage    `json:"callMessage,omitempty" yaml:"callMessage,omitempty"`
	DataMessage              *JsonDataMessage    `json:"dataMessage,omitempty" yaml:"dataMessage,omitempty"`
	HasContent               bool                `json:"hasContent,omitempty" yaml:"hasContent,omitempty"`
	HasLegacyMessage         bool                `json:"hasLegacyMessage,omitempty" yaml:"hasLegacyMessage,omitempty"`
	IsUnidentifiedSender     bool                `json:"isUnidentifiedSender,omitempty" yaml:"isUnidentifiedSender,omitempty"`
	Receipt                  *JsonReceiptMessage `json:"receipt,omitempty" yaml:"receipt,omitempty"`
	Relay                    string              `json:"relay,omitempty" yaml:"relay,omitempty"` // this field is no longer available and will never be populated
	ServerDeliveredTimestamp int64               `json:"serverDeliveredTimestamp,omitempty" yaml:"serverDeliveredTimestamp,omitempty"`
	ServerTimestamp          int64               `json:"serverTimestamp,omitempty" yaml:"serverTimestamp,omitempty"`
	Source                   *JsonAddress        `json:"source,omitempty" yaml:"source,omitempty"`
	SourceDevice             int32               `json:"sourceDevice,omitempty" yaml:"sourceDevice,omitempty"`
	SyncMessage              *JsonSyncMessage    `json:"syncMessage,omitempty" yaml:"syncMessage,omitempty"`
	Timestamp                int64               `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	TimestampISO             string              `json:"timestampISO,omitempty" yaml:"timestampISO,omitempty"`
	Type                     string              `json:"type,omitempty" yaml:"type,omitempty"`
	Typing                   *JsonTypingMessage  `json:"typing,omitempty" yaml:"typing,omitempty"`
	Username                 string              `json:"username,omitempty" yaml:"username,omitempty"`
	UUID                     string              `json:"uuid,omitempty" yaml:"uuid,omitempty"`
}

type JsonMessageRequestResponseMessage struct {
	GroupId string       `json:"groupId,omitempty" yaml:"groupId,omitempty"`
	Person  *JsonAddress `json:"person,omitempty" yaml:"person,omitempty"`
	Type    string       `json:"type,omitempty" yaml:"type,omitempty"`
}

type JsonPreview struct {
	Attachment *JsonAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty"`
	Title      string          `json:"title,omitempty" yaml:"title,omitempty"`
	Url        string          `json:"url,omitempty" yaml:"url,omitempty"`
}

// JsonQuote: A quote is a reply to a previous message. ID is the sent time of the message being replied to
type JsonQuote struct {
	Attachments []*JsonQuotedAttachment `json:"attachments,omitempty" yaml:"attachments,omitempty"` // list of files attached to the quoted message
	Author      *JsonAddress            `json:"author,omitempty" yaml:"author,omitempty"`           // the author of the message being quoted
	ID          int64                   `json:"id,omitempty" yaml:"id,omitempty"`                   // the client timestamp of the message being quoted
	Mentions    []*JsonMention          `json:"mentions,omitempty" yaml:"mentions,omitempty"`       // list of mentions in the quoted message
	Text        string                  `json:"text,omitempty" yaml:"text,omitempty"`               // the body of the message being quoted
}

type JsonQuotedAttachment struct {
	ContentType string          `json:"contentType,omitempty" yaml:"contentType,omitempty"`
	FileName    string          `json:"fileName,omitempty" yaml:"fileName,omitempty"`
	Thumbnail   *JsonAttachment `json:"thumbnail,omitempty" yaml:"thumbnail,omitempty"`
}

type JsonReaction struct {
	Emoji               string       `json:"emoji,omitempty" yaml:"emoji,omitempty"`                             // the emoji to react with
	Remove              bool         `json:"remove,omitempty" yaml:"remove,omitempty"`                           // set to true to remove the reaction. requires emoji be set to previously reacted emoji
	TargetAuthor        *JsonAddress `json:"targetAuthor,omitempty" yaml:"targetAuthor,omitempty"`               // the author of the message being reacted to
	TargetSentTimestamp int64        `json:"targetSentTimestamp,omitempty" yaml:"targetSentTimestamp,omitempty"` // the client timestamp of the message being reacted to
}

type JsonReadMessage struct {
	Sender    *JsonAddress `json:"sender,omitempty" yaml:"sender,omitempty"`
	Timestamp int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type JsonReceiptMessage struct {
	Timestamps []int64 `json:"timestamps,omitempty" yaml:"timestamps,omitempty"`
	Type       string  `json:"type,omitempty" yaml:"type,omitempty"`
	When       int64   `json:"when,omitempty" yaml:"when,omitempty"`
}

type JsonSentTranscriptMessage struct {
	Destination              *JsonAddress      `json:"destination,omitempty" yaml:"destination,omitempty"`
	ExpirationStartTimestamp int64             `json:"expirationStartTimestamp,omitempty" yaml:"expirationStartTimestamp,omitempty"`
	IsRecipientUpdate        bool              `json:"isRecipientUpdate,omitempty" yaml:"isRecipientUpdate,omitempty"`
	Message                  *JsonDataMessage  `json:"message,omitempty" yaml:"message,omitempty"`
	Timestamp                int64             `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	UnidentifiedStatus       map[string]string `json:"unidentifiedStatus,omitempty" yaml:"unidentifiedStatus,omitempty"`
}

type JsonSticker struct {
	Attachment *JsonAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty"`
	Image      string          `json:"image,omitempty" yaml:"image,omitempty"`
	PackID     string          `json:"packID,omitempty" yaml:"packID,omitempty"`
	PackKey    string          `json:"packKey,omitempty" yaml:"packKey,omitempty"`
	StickerID  int32           `json:"stickerID,omitempty" yaml:"stickerID,omitempty"`
}

type JsonStickerPackOperationMessage struct {
	PackID  string `json:"packID,omitempty" yaml:"packID,omitempty"`
	PackKey string `json:"packKey,omitempty" yaml:"packKey,omitempty"`
	Type    string `json:"type,omitempty" yaml:"type,omitempty"`
}

type JsonSyncMessage struct {
	BlockedList            *JsonBlockedListMessage            `json:"blockedList,omitempty" yaml:"blockedList,omitempty"`
	Configuration          *ConfigurationMessage              `json:"configuration,omitempty" yaml:"configuration,omitempty"`
	Contacts               *JsonAttachment                    `json:"contacts,omitempty" yaml:"contacts,omitempty"`
	ContactsComplete       bool                               `json:"contactsComplete,omitempty" yaml:"contactsComplete,omitempty"`
	FetchType              string                             `json:"fetchType,omitempty" yaml:"fetchType,omitempty"`
	Groups                 *JsonAttachment                    `json:"groups,omitempty" yaml:"groups,omitempty"`
	MessageRequestResponse *JsonMessageRequestResponseMessage `json:"messageRequestResponse,omitempty" yaml:"messageRequestResponse,omitempty"`
	ReadMessages           []*JsonReadMessage                 `json:"readMessages,omitempty" yaml:"readMessages,omitempty"`
	Request                string                             `json:"request,omitempty" yaml:"request,omitempty"`
	Sent                   *JsonSentTranscriptMessage         `json:"sent,omitempty" yaml:"sent,omitempty"`
	StickerPackOperations  []*JsonStickerPackOperationMessage `json:"stickerPackOperations,omitempty" yaml:"stickerPackOperations,omitempty"`
	Verified               *JsonVerifiedMessage               `json:"verified,omitempty" yaml:"verified,omitempty"`
	ViewOnceOpen           *JsonViewOnceOpenMessage           `json:"viewOnceOpen,omitempty" yaml:"viewOnceOpen,omitempty"`
}

type JsonTypingMessage struct {
	Action    string `json:"action,omitempty" yaml:"action,omitempty"`
	GroupId   string `json:"groupId,omitempty" yaml:"groupId,omitempty"`
	Timestamp int64  `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type JsonVerifiedMessage struct {
	Destination *JsonAddress `json:"destination,omitempty" yaml:"destination,omitempty"`
	IdentityKey string       `json:"identityKey,omitempty" yaml:"identityKey,omitempty"`
	Timestamp   int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
	Verified    string       `json:"verified,omitempty" yaml:"verified,omitempty"`
}

type JsonViewOnceOpenMessage struct {
	Sender    *JsonAddress `json:"sender,omitempty" yaml:"sender,omitempty"`
	Timestamp int64        `json:"timestamp,omitempty" yaml:"timestamp,omitempty"`
}

type Name struct {
	Display *Optional `json:"display,omitempty" yaml:"display,omitempty"`
	Family  *Optional `json:"family,omitempty" yaml:"family,omitempty"`
	Given   *Optional `json:"given,omitempty" yaml:"given,omitempty"`
	Middle  *Optional `json:"middle,omitempty" yaml:"middle,omitempty"`
	Prefix  *Optional `json:"prefix,omitempty" yaml:"prefix,omitempty"`
	Suffix  *Optional `json:"suffix,omitempty" yaml:"suffix,omitempty"`
}

type OfferMessage struct {
	ID     int64  `json:"id,omitempty" yaml:"id,omitempty"`
	Opaque string `json:"opaque,omitempty" yaml:"opaque,omitempty"`
	Sdp    string `json:"sdp,omitempty" yaml:"sdp,omitempty"`
	Type   *Type  `json:"type,omitempty" yaml:"type,omitempty"`
}

type Optional struct {
	Present bool `json:"present,omitempty" yaml:"present,omitempty"`
}

type RemoteDelete struct {
	TargetSentTimestamp int64 `json:"targetSentTimestamp,omitempty" yaml:"targetSentTimestamp,omitempty"`
}

type SharedContact struct {
	Address      *Optional `json:"address,omitempty" yaml:"address,omitempty"`
	Avatar       *Optional `json:"avatar,omitempty" yaml:"avatar,omitempty"`
	Email        *Optional `json:"email,omitempty" yaml:"email,omitempty"`
	Name         *Name     `json:"name,omitempty" yaml:"name,omitempty"`
	Organization *Optional `json:"organization,omitempty" yaml:"organization,omitempty"`
	Phone        *Optional `json:"phone,omitempty" yaml:"phone,omitempty"`
}

type Type struct {
}
